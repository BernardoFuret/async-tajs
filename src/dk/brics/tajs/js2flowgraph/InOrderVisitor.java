package dk.brics.tajs.js2flowgraph;

import com.google.javascript.jscomp.parsing.ParseTreeVisitor;
import com.google.javascript.jscomp.parsing.parser.trees.*;

import java.util.List;

public class InOrderVisitor extends ParseTreeVisitor<Void> {

    public void in(ArrayLiteralExpressionTree tree) {
    }

    public void in(ProgramTree tree) {
    }

    public void in(BlockTree tree) {
    }

    public void in(BreakStatementTree breakStatementtree) {
    }

    public void in(CatchTree tree) {
    }

    public void in(ComputedPropertyAssignmentTree tree) {
    }

    public void in(ConditionalExpressionTree tree) {
    }

    public void in(ContinueStatementTree tree) {
    }

    public void in(DoWhileStatementTree tree) {
    }

    public void in(MemberLookupExpressionTree tree) {
    }

    public void in(EmptyStatementTree tree) {
    }

    public void in(ExpressionStatementTree tree) {
    }

    public void in(ForInStatementTree tree) {
    }

    public void in(ForStatementTree tree) {
    }

    public void in(CallExpressionTree tree) {
    }

    public void in(FunctionDeclarationTree tree) {
    }

    public void in(IfStatementTree tree) {
    }

    public void in(BinaryOperatorTree tree) {
    }

    public void in(LabelledStatementTree tree) {
    }

    public void in(IdentifierExpressionTree tree) {
    }

    public void in(NewExpressionTree tree) {
    }

    public void in(ObjectLiteralExpressionTree tree) {
    }

    public void in(ParenExpressionTree tree) {
    }

    public void in(MemberExpressionTree tree) {
    }

    public void in(ReturnStatementTree tree) {
    }

    public void in(CaseClauseTree tree) {
    }

    public void in(SwitchStatementTree tree) {
    }

    public void in(ThrowStatementTree tree) {
    }

    public void in(TryStatementTree tree) {
    }

    public void in(UnaryExpressionTree tree) {
    }

    public void in(VariableStatementTree tree) {
    }

    public void in(VariableDeclarationListTree tree) {
    }

    public void in(VariableDeclarationTree decl) {
    }

    public void in(WhileStatementTree tree) {
    }

    public void in(WithStatementTree tree) {
    }

    public void in(DebuggerStatementTree tree) {
    }

    public void in(ThisExpressionTree tree) {
    }

    public void in(DefaultClauseTree tree) {
    }

    public void in(NullTree literalNode) {
    }

    public void in(PostfixExpressionTree tree) {
    }

    public void in(CommaExpressionTree tree) {
    }

    public void in(FinallyTree tree) {
    }

    public void in(GetAccessorTree tree) {
    }

    public void in(SetAccessorTree tree) {
    }

    public void in(PropertyNameAssignmentTree tree) {
    }

    public void in(FormalParameterListTree tree) {
    }

    public void in(DefaultParameterTree tree) {
    }

    public void in(RestParameterTree tree) {
    }

    public void in(SpreadExpressionTree tree) {
    }

    public void in(ClassDeclarationTree tree) {
    }

    public void in(SuperExpressionTree tree) {
    }

    public void in(YieldExpressionTree tree) {
    }

    public void in(ForOfStatementTree tree) {
    }

    public void in(ExportDeclarationTree tree) {
    }

    public void in(ExportSpecifierTree tree) {
    }

    public void in(ImportDeclarationTree tree) {
    }

    public void in(ImportSpecifierTree tree) {
    }

    public void in(ModuleImportTree tree) {
    }

    public void in(MissingPrimaryExpressionTree tree) {
    }

    public void inBooleanLiteral(LiteralExpressionTree tree) {
    }

    public void inIllegalToken(ParseTree tree) {
    }

    public void inNullLiteral(LiteralExpressionTree tree) {
    }

    public void inNumberLiteral(LiteralExpressionTree tree) {
    }

    public void inRegExpLiteral(LiteralExpressionTree tree) {
    }

    public void inStringLiteral(LiteralExpressionTree tree) {
    }

    public void inTemplateString(LiteralExpressionTree tree) {
    }

    public void inUnsupportedLanguageFeature(ParseTree node, String feature) {
    }

    public void out(ArrayLiteralExpressionTree tree) {
    }

    public void out(ProgramTree tree) {
    }

    public void out(BlockTree tree) {
    }

    public void out(BreakStatementTree breakStatementtree) {
    }

    public void out(CatchTree tree) {
    }

    public void out(ComputedPropertyAssignmentTree tree) {
    }

    public void out(ConditionalExpressionTree tree) {
    }

    public void out(ContinueStatementTree tree) {
    }

    public void out(DoWhileStatementTree tree) {
    }

    public void out(MemberLookupExpressionTree tree) {
    }

    public void out(EmptyStatementTree tree) {
    }

    public void out(ExpressionStatementTree tree) {
    }

    public void out(ForInStatementTree tree) {
    }

    public void out(ForStatementTree tree) {
    }

    public void out(CallExpressionTree tree) {
    }

    public void out(FunctionDeclarationTree tree) {
    }

    public void out(IfStatementTree tree) {
    }

    public void out(BinaryOperatorTree tree) {
    }

    public void out(LabelledStatementTree tree) {
    }

    public void out(IdentifierExpressionTree tree) {
    }

    public void out(NewExpressionTree tree) {
    }

    public void out(ObjectLiteralExpressionTree tree) {
    }

    public void out(ParenExpressionTree tree) {
    }

    public void out(MemberExpressionTree tree) {
    }

    public void out(ReturnStatementTree tree) {
    }

    public void out(CaseClauseTree tree) {
    }

    public void out(SwitchStatementTree tree) {
    }

    public void out(ThrowStatementTree tree) {
    }

    public void out(TryStatementTree tree) {
    }

    public void out(UnaryExpressionTree tree) {
    }

    public void out(VariableStatementTree tree) {
    }

    public void out(VariableDeclarationListTree tree) {
    }

    public void out(VariableDeclarationTree decl) {
    }

    public void out(WhileStatementTree tree) {
    }

    public void out(WithStatementTree tree) {
    }

    public void out(DebuggerStatementTree tree) {
    }

    public void out(ThisExpressionTree tree) {
    }

    public void out(DefaultClauseTree tree) {
    }

    public void out(NullTree literalNode) {
    }

    public void out(PostfixExpressionTree tree) {
    }

    public void out(CommaExpressionTree tree) {
    }

    public void out(FinallyTree tree) {
    }

    public void out(GetAccessorTree tree) {
    }

    public void out(SetAccessorTree tree) {
    }

    public void out(PropertyNameAssignmentTree tree) {
    }

    public void out(FormalParameterListTree tree) {
    }

    public void out(DefaultParameterTree tree) {
    }

    public void out(RestParameterTree tree) {
    }

    public void out(SpreadExpressionTree tree) {
    }

    public void out(ClassDeclarationTree tree) {
    }

    public void out(SuperExpressionTree tree) {
    }

    public void out(YieldExpressionTree tree) {
    }

    public void out(ForOfStatementTree tree) {
    }

    public void out(ExportDeclarationTree tree) {
    }

    public void out(ExportSpecifierTree tree) {
    }

    public void out(ImportDeclarationTree tree) {
    }

    public void out(ImportSpecifierTree tree) {
    }

    public void out(ModuleImportTree tree) {
    }

    public void out(MissingPrimaryExpressionTree tree) {
    }

    public void outBooleanLiteral(LiteralExpressionTree tree) {
    }

    public void outIllegalToken(ParseTree tree) {
    }

    public void outNullLiteral(LiteralExpressionTree tree) {
    }

    public void outNumberLiteral(LiteralExpressionTree tree) {
    }

    public void outRegExpLiteral(LiteralExpressionTree tree) {
    }

    public void outStringLiteral(LiteralExpressionTree tree) {
    }

    public void outTemplateString(LiteralExpressionTree tree) {
    }

    public void outUnsupportedLanguageFeature(ParseTree node, String feature) {
    }

    private void process(List<? extends ParseTree> trees) {
        for (ParseTree tree : trees) {
            process(tree);
        }

    }

    @Override
    public Void processArrayLiteral(ArrayLiteralExpressionTree tree) {
        in(tree);
        process(tree.elements);
        out(tree);
        return null;
    }

    @Override
    public Void processAstRoot(ProgramTree tree) {
        in(tree);
        process(tree.sourceElements);
        out(tree);
        return null;
    }

    @Override
    public Void processBinaryExpression(BinaryOperatorTree tree) {
        in(tree);
        process(tree.left);
        process(tree.right);
        out(tree);
        return null;
    }

    @Override
    public Void processBlock(BlockTree tree) {
        in(tree);
        process(tree.statements);
        out(tree);
        return null;
    }

    @Override
    public Void processBooleanLiteral(LiteralExpressionTree tree) {
        inBooleanLiteral(tree);
        outBooleanLiteral(tree);
        return null;
    }

    @Override
    public Void processBreakStatement(BreakStatementTree breakStatementTree) {
        in(breakStatementTree);
        out(breakStatementTree);
        return null;
    }

    @Override
    public Void processCatchClause(CatchTree tree) {
        in(tree);
        process(tree.catchBody);
        out(tree);
        return null;
    }

    @Override
    public Void processClassDeclaration(ClassDeclarationTree tree) {
        in(tree);
        process(tree.superClass);
        process(tree.elements);
        out(tree);
        return null;
    }

    @Override
    public Void processCommaExpression(CommaExpressionTree tree) {
        in(tree);
        process(tree.expressions);
        out(tree);
        return null;
    }

    @Override
    public Void processComputedProperty(ComputedPropertyAssignmentTree tree) {
        in(tree);
        process(tree.property);
        process(tree.value);
        out(tree);
        return null;
    }

    @Override
    public Void processConditionalExpression(ConditionalExpressionTree tree) {
        in(tree);
        process(tree.condition);
        process(tree.left);
        process(tree.right);
        out(tree);
        return null;
    }

    @Override
    public Void processContinueStatement(ContinueStatementTree tree) {
        in(tree);
        out(tree);
        return null;
    }

    @Override
    public Void processDebuggerStatement(DebuggerStatementTree tree) {
        in(tree);
        out(tree);
        return null;
    }

    @Override
    public Void processDefaultParameter(DefaultParameterTree tree) {
        in(tree);
        process(tree.identifier);
        process(tree.expression);
        out(tree);
        return null;
    }

    @Override
    public Void processDoLoop(DoWhileStatementTree tree) {
        in(tree);
        process(tree.body);
        process(tree.condition);
        out(tree);
        return null;
    }

    @Override
    public Void processElementGet(MemberLookupExpressionTree tree) {
        in(tree);
        process(tree.operand);
        process(tree.memberExpression);
        out(tree);
        return null;
    }

    @Override
    public Void processEmptyStatement(EmptyStatementTree tree) {
        in(tree);
        out(tree);
        return null;
    }

    @Override
    public Void processExportDecl(ExportDeclarationTree tree) {
        in(tree);
        process(tree.declaration);
        process(tree.exportSpecifierList);
        out(tree);
        return null;
    }

    @Override
    public Void processExportSpec(ExportSpecifierTree tree) {
        in(tree);
        out(tree);
        return null;
    }

    @Override
    public Void processExpressionStatement(ExpressionStatementTree tree) {
        in(tree);
        process(tree.expression);
        out(tree);
        return null;
    }

    @Override
    public Void processFinally(FinallyTree tree) {
        in(tree);
        process(tree.block);
        out(tree);
        return null;
    }

    @Override
    public Void processForInLoop(ForInStatementTree tree) {
        in(tree);
        process(tree.initializer);
        process(tree.collection);
        process(tree.body);
        out(tree);
        return null;
    }

    @Override
    public Void processForLoop(ForStatementTree tree) {
        in(tree);
        process(tree.initializer);
        process(tree.condition);
        process(tree.increment);
        process(tree.body);
        out(tree);
        return null;
    }

    @Override
    public Void processForOf(ForOfStatementTree tree) {
        in(tree);
        process(tree.initializer);
        process(tree.collection);
        process(tree.body);
        out(tree);
        return null;
    }

    @Override
    public Void processFormalParameterList(FormalParameterListTree tree) {
        in(tree);
        process(tree.parameters);
        out(tree);
        return null;
    }

    @Override
    public Void processFunction(FunctionDeclarationTree tree) {
        in(tree);
        process(tree.formalParameterList);
        process(tree.functionBody);
        out(tree);
        return null;
    }

    @Override
    public Void processFunctionCall(CallExpressionTree tree) {
        in(tree);
        process(tree.operand);
        process(tree.arguments.arguments);
        out(tree);
        return null;
    }

    @Override
    public Void processGetAccessor(GetAccessorTree tree) {
        in(tree);
        process(tree.body);
        out(tree);
        return null;
    }

    @Override
    public Void processIfStatement(IfStatementTree tree) {
        in(tree);
        process(tree.condition);
        process(tree.ifClause);
        process(tree.elseClause);
        out(tree);
        return null;
    }

    @Override
    public Void processIllegalToken(ParseTree node) {
        inIllegalToken(node);
        outIllegalToken(node);
        return null;
    }

    @Override
    public Void processImportDecl(ImportDeclarationTree tree) {
        in(tree);
        process(tree.importSpecifierList);
        out(tree);
        return null;
    }

    @Override
    public Void processImportSpec(ImportSpecifierTree tree) {
        in(tree);
        out(tree);
        return null;
    }

    @Override
    public Void processLabeledStatement(LabelledStatementTree tree) {
        in(tree);
        process(tree.statement);
        out(tree);
        return null;
    }

    @Override
    public Void processMissingExpression(MissingPrimaryExpressionTree tree) {
        in(tree);
        out(tree);
        return null;
    }

    @Override
    public Void processModuleImport(ModuleImportTree tree) {
        in(tree);
        out(tree);
        return null;
    }

    @Override
    public Void processName(IdentifierExpressionTree tree) {
        in(tree);
        out(tree);
        return null;
    }

    @Override
    public Void processNewExpression(NewExpressionTree tree) {
        in(tree);
        process(tree.operand);
        process(tree.arguments);
        out(tree);
        return null;
    }

    @Override
    public Void processNull(NullTree literalNode) {
        in(literalNode);
        out(literalNode);
        return null;
    }

    @Override
    public Void processNullLiteral(LiteralExpressionTree tree) {
        inNullLiteral(tree);
        outNullLiteral(tree);
        return null;
    }

    @Override
    public Void processNumberLiteral(LiteralExpressionTree tree) {
        inNumberLiteral(tree);
        outNumberLiteral(tree);
        return null;
    }

    @Override
    public Void processObjectLiteral(ObjectLiteralExpressionTree tree) {
        in(tree);
        process(tree.propertyNameAndValues);
        out(tree);
        return null;
    }

    @Override
    public Void processParenthesizedExpression(ParenExpressionTree tree) {
        in(tree);
        process(tree.expression);
        out(tree);
        return null;
    }

    @Override
    public Void processPostfixExpression(PostfixExpressionTree tree) {
        in(tree);
        process(tree.operand);
        out(tree);
        return null;
    }

    @Override
    public Void processPropertyGet(MemberExpressionTree tree) {
        in(tree);
        process(tree.operand);
        out(tree);
        return null;
    }

    @Override
    public Void processPropertyNameAssignment(PropertyNameAssignmentTree tree) {
        in(tree);
        process(tree.value);
        out(tree);
        return null;
    }

    @Override
    public Void processRegExpLiteral(LiteralExpressionTree tree) {
        inRegExpLiteral(tree);
        outRegExpLiteral(tree);
        return null;
    }

    @Override
    public Void processRestParameter(RestParameterTree tree) {
        in(tree);
        out(tree);
        return null;
    }

    @Override
    public Void processReturnStatement(ReturnStatementTree tree) {
        in(tree);
        process(tree.expression);
        out(tree);
        return null;
    }

    @Override
    public Void processSetAccessor(SetAccessorTree tree) {
        in(tree);
        process(tree.body);
        out(tree);
        return null;
    }

    @Override
    public Void processSpreadExpression(SpreadExpressionTree tree) {
        in(tree);
        process(tree.expression);
        out(tree);
        return null;
    }

    @Override
    public Void processStringLiteral(LiteralExpressionTree tree) {
        inStringLiteral(tree);
        outStringLiteral(tree);
        return null;
    }

    @Override
    public Void processSuper(SuperExpressionTree tree) {
        in(tree);
        out(tree);
        return null;
    }

    @Override
    public Void processSwitchCase(CaseClauseTree tree) {
        in(tree);
        process(tree.expression);
        process(tree.statements);
        out(tree);
        return null;
    }

    @Override
    public Void processSwitchDefault(DefaultClauseTree tree) {
        in(tree);
        process(tree.statements);
        out(tree);
        return null;
    }

    @Override
    public Void processSwitchStatement(SwitchStatementTree tree) {
        in(tree);
        process(tree.expression);
        process(tree.caseClauses);
        out(tree);
        return null;
    }

    @Override
    public Void processTemplateString(LiteralExpressionTree tree) {
        inTemplateString(tree);
        outTemplateString(tree);
        return null;
    }

    @Override
    public Void processThisExpression(ThisExpressionTree tree) {
        in(tree);
        out(tree);
        return null;
    }

    @Override
    public Void processThrowStatement(ThrowStatementTree tree) {
        in(tree);
        process(tree.value);
        out(tree);
        return null;
    }

    @Override
    public Void processTryStatement(TryStatementTree tree) {
        in(tree);
        process(tree.body);
        process(tree.catchBlock);
        process(tree.finallyBlock);
        out(tree);
        return null;
    }

    @Override
    public Void processUnaryExpression(UnaryExpressionTree tree) {
        in(tree);
        process(tree.operand);
        out(tree);
        return null;
    }

    @Override
    public Void processVariableDeclaration(VariableDeclarationTree decl) {
        in(decl);
        process(decl.lvalue);
        process(decl.initializer);
        out(decl);
        return null;
    }

    @Override
    public Void processVariableDeclarationList(VariableDeclarationListTree tree) {
        in(tree);
        process(tree.declarations.asList());
        out(tree);
        return null;
    }

    @Override
    public Void processVariableStatement(VariableStatementTree tree) {
        in(tree);
        process(tree.declarations);
        out(tree);
        return null;
    }

    @Override
    public Void processWhileLoop(WhileStatementTree tree) {
        in(tree);
        process(tree.condition);
        process(tree.body);
        out(tree);
        return null;
    }

    @Override
    public Void processWithStatement(WithStatementTree tree) {
        in(tree);
        process(tree.expression);
        process(tree.body);
        out(tree);
        return null;
    }

    @Override
    public Void processYield(YieldExpressionTree tree) {
        in(tree);
        process(tree.expression);
        out(tree);
        return null;
    }

    @Override
    public Void unsupportedLanguageFeature(ParseTree node, String feature) {
        inUnsupportedLanguageFeature(node, feature);
        outUnsupportedLanguageFeature(node, feature);
        return null;
    }

    public Void process(ParseTree node) {
        if (node != null) {
            super.process(node);
        }
        return null;
    }

}
